#!/usr/bin/env python3

import argparse
import os
import re
import pprint as pp
import sys
import certifi

from kbr import file_utils
from tabulate import tabulate
import json
import time

from bioblend.galaxy import GalaxyInstance

sys.path.append(".")

import kbr.config_utils as config_utils
import kbr.log_utils as logger
import kbr.mq_utils as mq_utils
import kbr.version_utils as version_utils
import kbr.args_utils as args_utils
import kbr.string_utils as string_utils
import kbr.timedate_utils as timedate_utils
import kbr.email_utils as email_utils

import nels_galaxy_api.api_requests as api_requests
import nels_galaxy_api.utils as nga_utils


verbose = False
version = version_utils.as_string()

mq = mq_utils.Mq()
galaxy_config = None

def readable_date(timestamp:str) -> str:

    if timestamp is None:
        return None

    timestamp = timestamp.replace('T', ' ')
    timestamp = re.sub(r'\.\d+', '', timestamp)

    return timestamp

def init( config_file:str) -> {}:
    config = config_utils.readin_config_file(config_file)
    logger.info("init from config ")

    master_url = config['master_url'].rstrip("/")

    instances = {}
    master_api = api_requests.ApiRequests(master_url, config['key'])
    config['master_api'] = master_api

#    nels_storage_client_key = config['nels_storage_client_key']
#    nels_storage_client_secret = config['nels_storage_client_secret']
#    nels_storage_url = config['nels_storage_url'].rstrip("/")

    global galaxy_config
    galaxy_config = config['galaxy_config']


    mq.connect(uri=config['mq_uri'])

    tmp_instances = {}

    for iid in config['instances']:
        instance = config['instances'][iid]

#        print( instance )


        if 'active' not in instance or not instance['active']:
            continue

        instance['api'] = api_requests.ApiRequests(instance['nga_url'].rstrip("/"), instance['nga_key'])
        instance['id']  = iid
        tmp_instances[ iid ] = instance
        tmp_instances[ instance['name'] ] = instance
#        print( tmp_instances )


    config['instances'] = tmp_instances
#    logger.debug( config )


    return config


def ping_hosts( config:{}):

    pings = []

    for instance_id in config['instances']:
        if config['instances'][ instance_id]['name'] == instance_id:
            continue

        instance = config['instances'][ instance_id]
        ping = {'name': instance['name'], 'reachable': False, 'secure reachable': False, 'api-version': 'NA', 'disk free': 'NA', 'bioblend':False}
        try:
            base_info = instance['api'].get_base()
            ping['api-version'] = base_info['version']
            ping['reachable'] = True
            disk_info = instance['api'].get_info()
            ping['disk free'] = f"{disk_info['perc_free']:>3.2f}% ({disk_info['free_gb']:>7.2f} GB)"
            ping['secure reachable'] = True
        except Exception as e:
#            print(e)
 #           logger.debug(f'Could not fetch all information for {instance["name"]}: {e}')
            pass

        try:
            gi = GalaxyInstance(instance['url'], key=instance['api_key'], verify=certifi.where())
            gi.histories.hl = gi.histories.get_histories()
            ping['bioblend'] = True
        except Exception as e:
#            print(e )
            logger.debug(f'Could not fetch all information for {instance["name"]}: {e}')



        pings.append( ping)

    print(tabulate( pings, headers="keys", tablefmt="psql" ))



def get_users( config:{}, instance_name:str=None):

    users = []
    brief = []

    if instance_name == "help":
        print("help: users [instance-name]")
        return


    if instance_name:
        global verbose
        verbose = True

    for instance_id in config['instances']:
        if instance_name and instance_id != instance_name:
            continue

        if config['instances'][ instance_id]['name'] != instance_id:
            continue

        instance = config['instances'][ instance_id]

        instance_users = []
        tmp_users = instance['api'].get_users()
        brief.append({'name': instance['name'], 'users': len(tmp_users)})

        if verbose:
            tmp_users = sorted(tmp_users, key=lambda x: x['email'].lower())

            for tmp_user in tmp_users:

                tmp_user['instance'] = instance['name']
                tmp_user['active'] = bool(tmp_user['active'])
                tmp_user['deleted'] = bool(tmp_user['deleted'])
#                del tmp_user['id']

                instance_users.append( tmp_user )

            users += sorted(instance_users, key=lambda x: x['email'].lower())


    if verbose:
        print(tabulate( users, headers="keys", tablefmt="psql" ))
    else:
        print(tabulate( brief, headers="keys", tablefmt="psql" ))


def get_histories( config:{}, instance_name:str=None, user_email:str=None):

    histories = []
    brief     = []

    if instance_name == "help":
        print("help: histories [instance-name] [user-email]")
        return


    if user_email:
        global verbose
        verbose = True


    for instance_id in config['instances']:
        if instance_name and instance_id != instance_name:
            continue


        if config['instances'][ instance_id]['name'] != instance_id:
            continue


        instance = config['instances'][ instance_id]

        users = instance['api'].get_users()
        users = sorted(users, key=lambda x: x['email'].lower())

        for user in users:
            if user_email is not None and user['email'] != user_email:
                continue

            tmp_histories = instance['api'].get_user_histories(user['email'])
            brief.append({'name':instance['name'], 'user': user['email'], 'histories': len( tmp_histories )})
            if verbose:
                for tmp_history in tmp_histories:
                    tmp_history['instance'] = instance['name']
                    tmp_history['changed'] = readable_date(tmp_history['update_time'])
                    del tmp_history['update_time']

                    tmp_history['user'] = user['email']
                    del tmp_history['hid_counter']

                    histories.append( tmp_history )


    if verbose:
        print(tabulate( histories, headers="keys", tablefmt="psql" ))
    else:
        print(tabulate( brief, headers="keys", tablefmt="psql"  ))


def get_exports( config:{}, instance_name:str=None, user_email:str=None):

    exports = []
    brief     = []

    if instance_name == "help":
        print("help: histories [instance-name] [user-email]")
        return


    for instance_id in config['instances']:
        if instance_name and instance_id != instance_name:
            continue


        if config['instances'][ instance_id]['name'] != instance_id:
            continue


        instance = config['instances'][ instance_id]

        users = instance['api'].get_users()
        users = sorted(users, key=lambda x: x['email'].lower())

        for user in users:
            if user_email is not None and user['email'] != user_email:
                continue

            tmp_exports = instance['api'].get_user_history_exports(user['email'])
            nr_exports = len( tmp_exports )
            if not nr_exports:
                continue

            brief.append({'name':instance['name'], 'user': user['email'], 'instance exports':  nr_exports })
            for tmp_export in tmp_exports:
                if not verbose:
                    del tmp_export['export_id']
                    del tmp_export['job_id']
                    del tmp_export['history_id']

                tmp_export['instance'] = instance['name']
                tmp_export['user'] = user['email']
                tmp_export['created'] = readable_date(tmp_export['create_time'])
                del tmp_export['create_time']

                exports.append( tmp_export )


    if user_email:
        print(tabulate( exports, headers="keys", tablefmt="psql" ))
    else:
        print(tabulate( brief, headers="keys", tablefmt="psql"  ))


def get_imports( config:{}, user_email:str=None):

    imports = []
    brief     = []

    if user_email == "help":
        print("help: imports <user-email>")
        return


    users =     config['master_api'].get_users()
    users = sorted(users, key=lambda x: x['email'].lower())

    for user in users:
        if user_email is not None and user['email'] != user_email:
            continue

        tmp_imports = config['master_api'].get_user_history_imports(user['id'])
        nr_imports = len( tmp_imports )
        if not nr_imports:
            continue

        brief.append({'user': user['email'], 'imports':  nr_imports })
        for tmp_import in tmp_imports:
#            print( tmp_import )
            if not verbose:
                del tmp_import['import_id']
                del tmp_import['job_id']
                del tmp_import['history_id']

            tmp_import['user'] = user['email']
            tmp_import['created'] = readable_date(tmp_import['create_time'])
            del tmp_import['create_time']

            imports.append( tmp_import )


    if verbose:
        print(tabulate( imports, headers="keys", tablefmt="psql" ))
    else:
        print(tabulate( brief, headers="keys", tablefmt="psql"  ))


def list_export_requests(config:{}, user:str=None, instance:str=None):
    requests = []
    brief     = []

    if user is not None and instance is not None:
        requests = config['master_api'].get_user_instance_exports(user, instance)

    elif instance is not None:
        requests = config['master_api'].get_instance_exports(instance)
    elif user is not None:
        requests = config['master_api'].get_user_exports(user)
    else:
        requests = config['master_api'].get_exports()

    for request in requests:

        request['update_time'] = readable_date(request['update_time'])
        request['create_time'] = readable_date(request['create_time'])

        if not verbose:
            for k in ['history_id', 'export_id', 'tmpfile', 'nels_id', 'destination']:
                del request[k]


    requests = sorted(requests, key=lambda x: (x['create_time'], x['update_time'] ))

    print(tabulate( requests, headers="keys", tablefmt="psql"   ))


def list_import_requests(config:{}, user:str=None):
    requests = []

    if user is not None:
        requests = config['master_api'].get_user_imports(user)
    else:
        requests = config['master_api'].get_imports()

    print( requests )

    for request in requests:

        request['update_time'] = readable_date(request['update_time'])
        request['create_time'] = readable_date(request['create_time'])

        if not verbose:
            for k in ['nels_id', 'source']:
                del request[k]


    requests = sorted(requests, key=lambda x: (x['create_time'], x['update_time'] ))

    print(tabulate( requests, headers="keys", tablefmt="psql"   ))


def log_requests(config, commands):
    if len(commands) == 0:
        commands.append( 'all')

    sub_command = commands.pop(0)

    if sub_command == 'all':
        pass
    elif sub_command == 'request':
        pass
    else:
        if sub_command != 'help':
            print( f"Error: Unknown command '{sub_command}'\n")

        print("Help:")
        print("==========================")
        print("log: <all> ")
        print("log: request [request-id] ")

def get_export_requests(config:{}, commands=[]):


    if len(commands) == 0:
        commands.append( 'all')

    sub_command = commands.pop(0)

    if sub_command == 'instance':
        instance_name = args_utils.get_or_fail(commands, "Instance name is required" )
        user_email = args_utils.get_or_default(commands, None )
        instance_id = config['instances'][instance_name]['id']

        list_export_requests(config, user_email, instance_id)

    elif sub_command == 'user':
        user_email = args_utils.get_or_fail(commands, "user email is required" )
        instance = args_utils.get_or_default(commands, None )
        if instance is not None:
            instance = config['instances'][instance]['id']
        list_export_requests(config, user_email, instance)
    elif sub_command == 'all':
        list_export_requests(config)
    elif sub_command == 'log':
        log_requests(config, commands)
    elif sub_command == 'queue':
        queue_job(config, commands)
        sys.exit()
    elif sub_command == 'requeue':
        requeue_job(config, commands)
        sys.exit()
    elif sub_command == 'restate':
        restate_job(config, commands)
        sys.exit()
    else:
        if sub_command != 'help':
            print( f"Error: Unknown command '{sub_command}'\n")

        print("Help:")
        print("==========================")
        print("requests: requests [all] ")
        print("requests: requests user user-email [instance]")
        print("requests: requests instance instance-name [email]")

        print("requests: requests queue ID [new-state]")
        print("requests: requests requeue ID new-state")
        print("requests: requests restate ID new-state")

def get_import_requests(config:{}, commands=[]):


    if len(commands) == 0:
        commands.append( 'all')

    sub_command = commands.pop(0)

    if sub_command == 'user':
        user_email = args_utils.get_or_fail(commands, "user email is required" )
        list_import_requests(config, user_email)
    elif sub_command == 'all':
        list_import_requests(config)
    elif sub_command == 'log':
        log_requests(config, commands)
    elif sub_command == 'queue':
        queue_job(config, commands)
        sys.exit()
    elif sub_command == 'requeue':
        requeue_job(config, commands)
        sys.exit()
    elif sub_command == 'restate':
        restate_job(config, commands)
        sys.exit()
    else:
        if sub_command != 'help':
            print( f"Error: Unknown command '{sub_command}'\n")

        print("Help:")
        print("==========================")
        print("requests: imports [all] ")
        print("requests: imports user-email")

        print("requests: imports queue ID [new-state]")
        print("requests: imports requeue ID new-state")
        print("requests: imports restate ID new-state")


def submit_mq_job(tracker_id:int, type:str) -> None:

    payload = {'tracker_id': tracker_id, "type":type}

    if mq is None:
        logger.error('MQ not configured, cannot send message')
        return

    mq.publish(body=json.dumps(payload))


def queue_job(config:{}, commands=[]):

    if len(commands) == 0:
        print("requests: queue job-id [new-state]")
        return

    job_id = args_utils.get_or_fail(commands, "Job id is required" )
    state = args_utils.get_or_default(commands, None )


    tracker = config['master_api'].get_export( job_id)
    if tracker is None:
        print(f"Unknown job id {job_id}")
        sys.exit(1)

    del tracker['id']
    del tracker['create_time']
    del tracker['update_time']

#    tracker = config['master_api'].post_export( job_id)

    if state is not None and state != tracker['state']:
        config['master_api'].update_export(job_id, {'state':state})
    else:
        state = tracker['state']

#    job_id = config['master_api'].decrypt( job_id )
    submit_mq_job( tracker_id=job_id, type="export")

def requeue_job(config:{}, commands=[]):

    if len(commands) == 0 or commands[0] == 'help':
        print("requests: requeue job-id new-state")
        return

    job_id = args_utils.get_or_fail(commands, "Job id is required" )
    state  = args_utils.get_or_fail(commands, "New job state is required" )


    tracker = config['master_api'].requeue_export( job_id, {'state':state})


def restate_job(config:{}, commands=[]):

    if len(commands) == 0 or commands[0] == 'help':
        print("requests: queue job-id [new-state]")
        return

    job_id = args_utils.get_or_fail(commands, "Job id is required" )
    state  = args_utils.get_or_fail(commands, "New job state is required" )

    config['master_api'].update_export(job_id, {'state':state})


def list_galaxy_info(config, commands):

    if len(commands) == 0:
        commands.append( 'help')

    sub_command = commands.pop(0)

    if sub_command == 'users':
        get_users(config, args_utils.get_or_default(commands, None))
        return
    elif sub_command == 'histories':
        get_histories(config, instance_name=args_utils.get_or_default(commands, None),
                              user_email=args_utils.get_or_default(commands, None))
        return
    elif sub_command == 'exports':
        get_exports(config, instance_name=args_utils.get_or_default(commands, None),
                    user_email=args_utils.get_or_default(commands, None))
        return
    elif sub_command == 'imports':
        get_imports(config, user_email=args_utils.get_or_default(commands, None))
        return
    else:
        if sub_command != 'help':
            print( f"Error: Unknown command '{sub_command}'\n")

        print("Help:")
        print("==========================")
        print("list: users [instance] ")
        print("list: histories [instance] [user]")
        print("list: exports [instance] [user]")
        print("list: imports [user]")


def nga_errors(config, commands):
    email = None
    if len(commands) and commands[0] == 'email':
        commands.pop(0)
        email = args_utils.get_or_fail(commands, 'email not provided')

    timerange = args_utils.get_or_default(commands, "")
    time_delta = 0
    if timerange != "":
        try:
            g = re.match(r'(\d+)([hd])', timerange)
            num, range = g.groups(0)
            ts = time.time()
            if range == 'h':
                time_delta = ts - 3600*int(num)
            elif range == 'd':
                time_delta = ts - 24*3600*int(num)
        except Exception as e:
            print( f"timerange {timerange} is invalid eg: 1d 2h  ")
            sys.exit(1)


    errors = [['id', 'instance','user','state','update time']]

    for request in config['master_api'].get_exports():
        if 'error' in request['state']:
            update_time = timedate_utils.datestr_to_ts(request['update_time'])
            update_time = timedate_utils.to_sec_since_epoch( update_time)

            if time_delta:
                if time_delta <= update_time:
                    errors.append([request['id'], request['instance'], request['user_email'], request['state'], readable_date(request['update_time']) ])
            else:
                errors.append([request['id'], request['instance'], request['user_email'], request['state'], readable_date(request['update_time'] )])

    if len(errors) > 1:
        errors = tabulate( errors, headers="firstrow", tablefmt="psql" )
        if email is not None and errors != "":
            email_utils.send_email("admin@usegalaxy.no",
                                   email,
                                   f"[NGA-ERRORs: list of errors from the last {timerange}",
                                   errors, )
        else:
            print(errors)

def nga_stuck_jobs(config, commands):

    timerange = args_utils.get_or_default(commands, "")
    time_delta = 0
    if timerange != "":
        try:
            g = re.match(r'(\d+)([hd])', timerange)
            num, range = g.groups(0)
            ts = time.time()
            if range == 'h':
                time_delta = ts - 3600*int(num)
            elif range == 'd':
                time_delta = ts - 24*3600*int(num)
        except Exception as e:
            print( f"timerange {timerange} is invalid eg: 1d 2h  ")
            sys.exit(1)

    errors = [['id', 'instance','user','state','create time']]

    for request in config['master_api'].get_exports():
        if request['update_time'] == '' or request['update_time'] is None:
            create_time = timedate_utils.datestr_to_ts(request['create_time'])
            create_time = timedate_utils.to_sec_since_epoch( create_time)

#            print( request )

            if time_delta:
                if time_delta <= create_time:
                    errors.append([request['id'], request['instance'], request['user_email'], request['state'], readable_date(request['create_time']) ])
            else:
                errors.append([request['id'], request['instance'], request['user_email'], request['state'], readable_date(request['create_time'] )])

    if len(errors) > 1:
        errors = tabulate( errors, headers="firstrow", tablefmt="psql" )
        print(errors)

def nga_unstick_jobs(config, commands):

    timerange = args_utils.get_or_default(commands, "")
    time_delta = 0
    if timerange != "":
        try:
            g = re.match(r'(\d+)([hd])', timerange)
            num, range = g.groups(0)
            ts = time.time()
            if range == 'h':
                time_delta = ts - 3600*int(num)
            elif range == 'd':
                time_delta = ts - 24*3600*int(num)
        except Exception as e:
            print( f"timerange {timerange} is invalid eg: 1d 2h  ")
            sys.exit(1)


    for request in config['master_api'].get_exports():
        if request['update_time'] == '' or request['update_time'] is None:
            create_time = timedate_utils.datestr_to_ts(request['create_time'])
            create_time = timedate_utils.to_sec_since_epoch( create_time)

            if time_delta:
                if time_delta <= create_time:
                    queue_job(config,  [request['id']])
                    if verbose:
                        print(f"Unstuck job {request['id']} for {request['user_email']} on {request['instance']}")
            else:
                queue_job(config,  [request['id']])
                if verbose:
                    print(f"Unstuck job {request['id']} for {request['user_email']} on {request['instance']}")


def list_tmpfiles(config, commands):
    delete_files = False
    if len(commands) and commands[0] == 'del':
        commands.pop(0)
        delete_files = True

    del_states = commands

    tfiles = [["filename", "size", "state"]]

    for request in config['master_api'].get_exports():
        if request['tmpfile'] and os.path.isfile(request['tmpfile']):
            if not del_states or (del_states and request['state'] in del_states):
                tfiles.append([ request['tmpfile'], file_utils.size( request['tmpfile'] ), request['state'] ])
                if verbose:
                    print( f"deleting file {request['tmpfile']}")
                os.unlink(request['tmpfile'])

    if not delete_files and len(tfiles) > 1:
        print(tabulate( tfiles, headers="firstrow", tablefmt="psql" ))



def utils(config, commands):

    if len(commands) == 0:
        commands.append( 'help')


    sub_command = commands.pop(0)

    if sub_command == 'tmpfiles':
        list_tmpfiles(config, commands)
        return
    elif sub_command == 'errors':
        nga_errors(config, commands)
        return
    elif sub_command == 'stuck':
        nga_stuck_jobs(config, commands)
        return
    elif sub_command == 'unstick':
        nga_unstick_jobs(config, commands)
        return
    elif sub_command == 'queue-flush':
        mq.flush()
        return
    elif sub_command == 'queue-size':
        print(f"Currently {mq.queue_length('default')} messages in the MQueue")
        return
    elif sub_command == 'decrypt':
        galaxy_config = config_utils.readin_config_file( galaxy_config)
        if 'id_secret' not in galaxy_config['galaxy']:
            id_secret = "USING THE DEFAULT IS NOT SECURE!"
        else:
            id_secret = galaxy_config['galaxy']['id_secret']
        nga_utils.init(id_secret)
        value = args_utils.get_or_fail(commands, "value is required" )
#        dec_value =
        print( f"{value}\t{nga_utils.decrypt_value( value )}")
        return
    elif sub_command == 'encrypt':
        galaxy_config = config_utils.readin_config_file( galaxy_config)
        if 'id_secret' not in galaxy_config['galaxy']:
            id_secret = "USING THE DEFAULT IS NOT SECURE!"
        else:
            id_secret = galaxy_config['galaxy']['id_secret']
        nga_utils.init(id_secret)
        value = args_utils.get_or_fail(commands, "value is required" )
        print( f"{value}\t{nga_utils.encrypt_value( value )}")
        return



    else:
        if sub_command != 'help':
            print( f"Error: Unknown command '{sub_command}'\n")

        print("Help:")
        print("==========================")
        print("utils: tmpfiles")
        print("utils: tmpfiles del")
        print("utils: stuck <1d, 2h>")
        print("utils: errors <1d, 2h>")
        print("utils: errors email [email add] <1d, 2h>")
        print("utils: queue-flush")
        print("utils: queue-size")
        print("utils: decrypt [value]")
        print("utils: encrypt [value]")
#        print("utils: exports [instance] [user]")


def export(config, commands):
    if len(commands) == 0:
        commands.append( 'help')

    sub_command = commands.pop(0)

    if sub_command == 'users':
        get_users(config, args_utils.get_or_default(commands, None))
        return
    else:
        if sub_command != 'help':
            print( f"Error: Unknown command '{sub_command}'\n")

        print("Help:")
        print("==========================")
        print("export: single [nels-id] [user-email] [instance] [history-id]")
        print("export: user [nels-id] [user-email] <instance> Instance can be: all>")


def main():

    commands = ['ping', 'list', 'exports', 'imports','utils', 'help']

    parser = argparse.ArgumentParser(description=f'nga_cli: command line tool for the NGA ({version})')

    parser.add_argument('-c', '--config',  help="NGA config file, or set env NGA_CONF", default=args_utils.get_env_var('NGA_CONF'))
#    parser.add_argument('-v', '--verbose', default=False, action="store_true",  help="Verbose output")
    parser.add_argument('-v', '--verbose', default=0, action="count", help="Increase the verbosity of logging output")
    parser.add_argument('command', nargs='*', help="{}".format(",".join(commands)))



    args = parser.parse_args()

    logger.init(name=f'nga_cli')
    logger.set_log_level(args.verbose)
    logger.info(f'nga-cli (v:{version})')

    if args.config is None:
        parser.print_usage()
        sys.exit( 1 )


    global verbose
    verbose = args.verbose

    config = init( args.config)

    args_utils.min_count(1, len(args.command), msg="nga-cli takes one of the following commands: {}".format(string_utils.comma_sep(commands)))

    command = args.command.pop(0)
    if command == 'ping':
        ping_hosts( config )
        sys.exit()
        sys.exit()
    elif command == 'list':
        list_galaxy_info(config, args.command)
    elif command == 'exports':
        get_export_requests(config, args.command)
        sys.exit()
    elif command == 'imports':
        get_import_requests(config, args.command)
        sys.exit()
    elif command == 'utils':
        utils(config, args.command)
        sys.exit()
#    elif command == 'export':
#        export(config, args.command)
#        sys.exit()

    else:
        print("The tool support the following commands: {}\n".format(string_utils.comma_sep( commands )))
        parser.print_usage()
        parser.add_argument('command', nargs='+', help="{}".format(",".join(commands)))
        sys.exit( 1 )




if __name__ == "__main__":
    main()


# class ExportBulk ( Export ):
#
#     def endpoint(self):
#         return("/export/")
#
#     def post(self, instance:str, user:str=None):
#         #        args =  self.arguments()
#         #post_values =  self.post_values()
#         nels_id = self.get_body_argument("nelsId", default=None)
#         location = self.get_body_argument("selectedFiles", default=None)
#         # This is a usegalaxy instance, get the information from the session
#
#         #This will not work!, need to use the CLI for this as the token will be wrong
#         histories = requests.get_user_histories(instance, user_id)
#         for history in histories:
#             try:
#                 self._register_export(instance, user, history['id'], nels_id, location)
#                 self.send_response_204()
#             except:
#                 self.send_response_400()
